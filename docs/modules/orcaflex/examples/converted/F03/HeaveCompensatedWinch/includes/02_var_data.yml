# VariableData Configuration
# Generated from: HeaveCompensatedWinch.yml
# Date: 2026-01-18 21:52:04
VariableData:
  Externalfunctions:
  - Name: PIDWinchControl
    Source: Embedded
    Script: "\"\"\"\r\nThis module is an example Python external function for use with OrcaFlex.\r\nThis example implements a PID controller (Proportional, Integral, Differential)\r\nthat is used to model a heave-compensated winch. For details see\r\n'External Function Examples.pdf' in the same folder as this file, and see the\r\nOrcFxAPI documentation OrcFxAPIHelp.exe (in the contents look for 'External\r\nFunctions' and 'Python Interface').\r\n\"\"\"\r\n\r\nimport json\r\n\r\n\r\nclass PIDstate(object):\r\n    def __init__(self):\r\n        self.valid = False\r\n        self.time = -OrcFxAPI.OrcinaInfinity()\r\n        self.signal = 0.0\r\n        self.iedt = 0.0\r\n        self.dedt = 0.0\r\n\r\n    def getStateAttributes(self):\r\n        return {\r\n            \"valid\": self.valid,\r\n            \"time\": self.time,\r\n            \"signal\": self.signal,\r\n            \"iedt\": self.iedt,\r\n            \"dedt\": self.dedt,\r\n        }\r\n\r\n    def setStateAttributes(self, attributes):\r\
      \n        self.valid = attributes[\"valid\"]\r\n        self.time = attributes[\"time\"]\r\n        self.signal = attributes[\"signal\"]\r\n        self.iedt = attributes[\"iedt\"]\r\n        self.dedt = attributes[\"dedt\"]\r\n\r\n\r\nclass PIDController(object):\r\n    def Initialise(self, info):\r\n        # In the Calculate() method we'll need to ask OrcaFlex for the value of\r\n        # our controlled variable. To do this we'll need an OrcFxAPI.Period to say\r\n        # we want the value 'now':\r\n        self.periodNow = OrcFxAPI.Period(OrcFxAPI.pnInstantaneousValue)\r\n\r\n        # And we'll need an ObjectExtra saying we want the value at the origin\r\n        # of the controlled object:\r\n        self.ObjectExtra = OrcFxAPI.ObjectExtra()\r\n        self.ObjectExtra.RigidBodyPos = (0.0, 0.0, 0.0)\r\n\r\n        # Convenience functions to get values from the object's tags:\r\n        def GetParam(paramName, default=None):\r\n            param = info.ModelObject.tags.get(paramName,\
      \ None)\r\n            if param is None:\r\n                if default is None:\r\n                    raise Exception(\r\n                        \"Parameter {} is required but is not included in \"\r\n                        \"the object tags.\".format(paramName)\r\n                    )\r\n                return default\r\n            return param\r\n\r\n        def GetFloatParam(paramName, default=None):\r\n            return float(GetParam(paramName, default))\r\n\r\n        # Name of model object whose result variable is to be controlled:\r\n        self.ControlledObject = info.Model[GetParam(\"ControlledObject\")]\r\n        # The result variable of that object to be controlled. This must be\r\n        # one of the results available for the ControlledObject on the results\r\n        # form in OrcaFlex:\r\n        self.ControlledVariable = GetParam(\"ControlledVariable\")\r\n        # The target value for that controlled variable. Its units are those of\r\n        # that controlled\
      \ variable in the OrcaFlex model:\r\n        self.TargetValue = GetFloatParam(\"TargetValue\", 0.0)\r\n        # The constants of the PID controller:\r\n        self.k0 = GetFloatParam(\"k0\", 0.0)  # constant part\r\n        self.kP = GetFloatParam(\"kP\", 0.0)  # scaling constant for the proportional part\r\n        self.kI = GetFloatParam(\"kI\", 0.0)  # scaling constant for the integral part\r\n        self.kD = GetFloatParam(\"kD\", 0.0)  # scaling constant for the differential part\r\n        # If no value of ControlStartTime is specified then default to -Infinity,\r\n        # so that we activate control at the start of the simulation:\r\n        self.ControlStartTime = GetFloatParam(\"ControlStartTime\", float(\"-inf\"))\r\n        # And default to not limiting the control variable:\r\n        self.MinValue = GetFloatParam(\"MinValue\", float(\"-inf\"))\r\n        self.MaxValue = GetFloatParam(\"MaxValue\", float(\"+inf\"))\r\n\r\n        # If info.StateData is not None then\
      \ we have been called when loading\r\n        # a simulation, so we need to restore the controller state\r\n        # to what our StoreState() method saved when the simulation was stored:\r\n        self.prev = PIDstate()\r\n        self.now = PIDstate()\r\n        if info.StateData:\r\n            state = json.loads(info.StateData)\r\n            self.now.setStateAttributes(state[\"now\"])\r\n            self.prev.setStateAttributes(state[\"prev\"])\r\n        else:\r\n            # This is a new simulation, so initialise the controller state:\r\n            self.prev.iedt = GetFloatParam(\"Initial e/D\", 0.0)\r\n            self.now.dedt = GetFloatParam(\"Initial De\", 0.0)\r\n\r\n        print(\"Initialised OK.\")\r\n\r\n    def Calculate(self, info):\r\n        # Don't start control until the specified time:\r\n        if info.SimulationTime < self.ControlStartTime:\r\n            return\r\n\r\n        # If this is a new time step, and not the first, then step self.now back\r\n\
      \        # to become our new self.prev:\r\n        if info.NewTimeStep and self.now.valid:\r\n            self.prev.time = self.now.time\r\n            self.prev.signal = self.now.signal\r\n            self.prev.iedt = self.now.iedt\r\n            self.prev.dedt = self.now.dedt\r\n            self.prev.valid = True\r\n\r\n        # Get the state values now:\r\n        self.now.time = info.SimulationTime\r\n        self.now.signal = self.ControlledObject.TimeHistory(\r\n            self.ControlledVariable,\r\n            self.periodNow,  # set up in Initialise() method to give the value 'now'\r\n            self.ObjectExtra,  # set up in Initialise() method\r\n        )[\r\n            0\r\n        ]  # TimeHistory returns an array, which in this case contains just 1 item, the value now\r\n        self.now.iedt = self.prev.iedt\r\n        self.now.valid = True\r\n\r\n        e = self.TargetValue - self.now.signal\r\n        if self.prev.valid:\r\n            prev_e = self.TargetValue\
      \ - self.prev.signal\r\n            dt = self.now.time - self.prev.time\r\n            self.now.dedt = (e - prev_e) / dt\r\n            self.now.iedt += dt * (e + prev_e) / 2.0\r\n            print(f\"t = {self.now.time}, e = {e}, dedt = {self.now.dedt}, iedt = {self.now.iedt}\")\r\n\r\n        info.Value = self.kP * e + self.kI * self.now.iedt + self.kD * self.now.dedt + self.k0\r\n        # Keep the value within the specified limits (if any):\r\n        info.Value = max(self.MinValue, min(info.Value, self.MaxValue))\r\n\r\n    def StoreState(self, info):\r\n        # The simulation is being stored, so we need to store our controlled state\r\n        # to the simulation file so that when the simulation is re-loaded our\r\n        # Initialise() method can restore to the same state. We use the built json module to get\r\n        # the controller state into a form suitable for putting into info.StateData,\r\n        # which OrcaFlex will store in the simulation file for us:\r\n    \
      \    state = {\r\n            \"now\": self.now.getStateAttributes(),\r\n            \"prev\": self.prev.getStateAttributes(),\r\n        }\r\n        info.StateData = json.dumps(state)\r\n"
    FunctionName: PIDController
    InitialValue: 0
    TimeStep: Outer time step
