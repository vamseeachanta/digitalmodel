"""
OrcaFlex / OrcaWave schematic capture helpers.

ABOUTME: Programmatic screenshot and mesh-schematic export for OrcaFlex (.dat/.sim)
and OrcaWave (.owd/.owr) models.

Key finding (WRK-310, 2026-02-24)
----------------------------------
- OrcFxAPI.Model     (.dat/.sim)  → has ``SaveModelView()``  → direct BMP/PNG capture
- OrcFxAPI.Diffraction (.owd/.owr) → NO ``SaveModelView()``  → use GDF mesh export +
  Plotly Mesh3d rendering, or fall back to Win32 screen capture of a running OrcaWave
  window.  OrcaWave files carry the binary header ``\\x08OrcaWave`` and are NOT
  loadable by ``OrcFxAPI.Model``.

Recommended approach for OrcaWave:
    1. ``d.SaveSymmetrisedBodyMesh(symmetry, tol, path)``  → body GDF
    2. ``d.SaveAutoGeneratedFreeSurfacePanelledZoneMesh(path)`` → free-surface GDF
    3. Render both GDFs with Plotly Mesh3d (see ``gdf_to_mesh3d()``)
    4. Export the figure to PNG via ``fig.write_image()`` (requires ``kaleido``)

For OrcaFlex models, ``save_orcaflex_views()`` is fully operational.
For OrcaWave models, ``capture_model_schematic()`` is a stub pending licence-holding
validation environment — the GDF-render path does not require a running solver.

References
----------
- Skill: ``workspace-hub/.claude/skills/engineering/marine-offshore/
          orcaflex-visualization/SKILL.md`` (v1.2.0+)
- Existing minimal pattern: ``scripts/capture_riser_views.py``
- Batch parallel pattern:   ``src/digitalmodel/solvers/orcaflex/opp_visualization.py``
- HTML embedding helper:    ``scripts/build_sme_report.py::img_to_base64()``
- WRK-310 exploration:      ``.claude/work-queue/pending/WRK-310.md``
"""

from __future__ import annotations

import base64
import logging
from pathlib import Path
from typing import Optional

logger = logging.getLogger(__name__)

# Optional imports — gracefully absent in environments without a licence
try:
    import OrcFxAPI as ofx

    _OFX_AVAILABLE = True
except ImportError:
    _OFX_AVAILABLE = False
    logger.debug("OrcFxAPI not available — schematic capture disabled")

try:
    import plotly.graph_objects as go
    import numpy as np

    _PLOTLY_AVAILABLE = True
except ImportError:
    _PLOTLY_AVAILABLE = False
    logger.debug("Plotly/numpy not available — GDF mesh rendering disabled")


# ---------------------------------------------------------------------------
# OrcaFlex (Model) — fully operational
# ---------------------------------------------------------------------------

THREE_VIEW_CAMERAS = {
    "elevation": dict(eye=dict(x=0, y=-2, z=0), up=dict(x=0, y=0, z=1)),
    "plan": dict(eye=dict(x=0, y=0, z=2), up=dict(x=0, y=1, z=0)),
    "perspective": dict(
        eye=dict(x=1.2, y=-1.2, z=0.8), up=dict(x=0, y=0, z=1)
    ),
}


def save_orcaflex_views(
    model_file: str | Path,
    output_dir: str | Path,
    *,
    run_statics: bool = True,
    view_size: float = 300.0,
    file_width: int = 960,
    file_height: int = 720,
) -> dict[str, Path]:
    """Capture three standard views of an OrcaFlex model via SaveModelView.

    Produces elevation, plan, and perspective BMP images in *output_dir*.
    Requires a valid OrcaFlex licence.

    Parameters
    ----------
    model_file:
        Path to ``.dat`` or ``.sim`` OrcaFlex model file.
    output_dir:
        Directory to write output images (created if absent).
    run_statics:
        If True, call ``CalculateStatics()`` before capturing views.
    view_size:
        ``ViewSize`` parameter passed to ``defaultViewParameters``.
    file_width, file_height:
        Pixel dimensions for the output images.

    Returns
    -------
    dict mapping view name → output Path (only entries that succeeded).
    """
    if not _OFX_AVAILABLE:
        raise ImportError("OrcFxAPI is not installed or no licence found.")

    model_file = Path(model_file)
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    model = ofx.Model()
    model.LoadData(str(model_file))
    if run_statics:
        model.CalculateStatics()

    saved: dict[str, Path] = {}
    view_angles = {
        "elevation": dict(ViewAzimuth=0, ViewElevation=0),
        "plan": dict(ViewAzimuth=0, ViewElevation=90),
        "perspective": dict(ViewAzimuth=315, ViewElevation=30),
    }

    for view_name, angles in view_angles.items():
        out_path = output_dir / f"{model_file.stem}_{view_name}.bmp"
        try:
            vp = model.defaultViewParameters
            vp.ViewSize = view_size
            vp.FileWidth = file_width
            vp.FileHeight = file_height
            for attr, val in angles.items():
                if hasattr(vp, attr):
                    setattr(vp, attr, val)
            model.SaveModelView(str(out_path), vp)
            saved[view_name] = out_path
            logger.info("Saved view %s → %s", view_name, out_path)
        except Exception as exc:
            logger.warning("SaveModelView failed for %s: %s", view_name, exc)

    return saved


# ---------------------------------------------------------------------------
# OrcaWave (Diffraction) — GDF mesh-render path
# ---------------------------------------------------------------------------

def gdf_to_mesh3d(gdf_path: str | Path, color: str = "coral") -> "go.Mesh3d | None":
    """Parse a WAMIT GDF panel file and return a Plotly Mesh3d trace.

    GDF format (4 quad corners per line after 4 header lines):
        header
        ulen  grav
        isx   isy
        npan
        x1 y1 z1  x2 y2 z2  x3 y3 z3  x4 y4 z4

    Parameters
    ----------
    gdf_path:
        Path to a ``.gdf`` file produced by
        ``Diffraction.SaveSymmetrisedBodyMesh()`` or similar.
    color:
        Plotly colour string for the surface.

    Returns
    -------
    ``go.Mesh3d`` trace, or ``None`` if parsing fails or Plotly unavailable.
    """
    if not _PLOTLY_AVAILABLE:
        logger.warning("Plotly not available — cannot render GDF mesh.")
        return None

    panels: list = []
    try:
        with open(gdf_path) as fh:
            lines = fh.readlines()
        for line in lines[4:]:
            parts = [float(x) for x in line.split() if x.strip()]
            if len(parts) == 12:
                panels.append(np.array(parts).reshape(4, 3))
    except Exception as exc:
        logger.warning("GDF parse failed for %s: %s", gdf_path, exc)
        return None

    if not panels:
        return None

    verts = np.vstack(panels)
    n = len(panels)
    i_idx = list(range(0, 4 * n, 4))
    j_idx = list(range(1, 4 * n, 4))
    k_idx = list(range(2, 4 * n, 4))
    return go.Mesh3d(
        x=verts[:, 0],
        y=verts[:, 1],
        z=verts[:, 2],
        i=i_idx,
        j=j_idx,
        k=k_idx,
        color=color,
        opacity=0.7,
        name=Path(gdf_path).stem,
    )


def capture_model_schematic(
    model_file: str | Path,
    output_png: str | Path,
    *,
    view: str = "perspective",
    free_surface_gdf: Optional[str | Path] = None,
    symmetry: Optional[int] = None,
    gdf_tol: float = 0.001,
) -> Path | None:
    """Capture a schematic image of an OrcaWave model as a PNG.

    STUB — documents the recommended approach; requires OrcFxAPI licence to
    export GDF files and ``kaleido`` to rasterise Plotly figures to PNG.

    Approach (OrcaWave / OrcFxAPI.Diffraction):
    1. Load the model with ``ofx.Diffraction()``
    2. Export body mesh:
       ``d.SaveSymmetrisedBodyMesh(PanelMeshSymmetry.XZ, tol, body_gdf)``
    3. Optionally export free-surface zone mesh:
       ``d.SaveAutoGeneratedFreeSurfacePanelledZoneMesh(fs_gdf)``
    4. Render both GDFs with ``gdf_to_mesh3d()`` → ``go.Figure``
    5. Set ``fig.update_layout(scene_camera=THREE_VIEW_CAMERAS[view])``
    6. Export: ``fig.write_image(output_png)`` (requires ``kaleido``)

    Alternative (OrcaFlex workaround):
    - Load the GDF body mesh into an ``ofx.Model`` via a VesselType with custom
      mesh; use ``SaveModelView()`` on that model.
    - Risk: no free-surface zone geometry available to OrcaFlex.

    Alternative (Win32 screen-capture fallback):
    - See ``src/digitalmodel/workflows/mcp_server/orcawave/vision/screen_capture.py``
      for ``OrcaWaveScreenCapture``.  Requires a running OrcaWave instance.
    - Fragile; not recommended for automated pipelines.

    Parameters
    ----------
    model_file:
        Path to ``.owd`` (input) or ``.owr`` (results) OrcaWave file.
    output_png:
        Destination PNG path.
    view:
        One of ``"elevation"``, ``"plan"``, ``"perspective"`` — maps to
        ``THREE_VIEW_CAMERAS`` presets matching Figure 30 in the WAMIT guide.
    free_surface_gdf:
        Optional pre-exported FDF/GDF path for the free-surface zone.  If
        ``None`` and ``ofx.Diffraction`` is loaded, the function attempts to
        export it automatically.
    symmetry:
        ``PanelMeshSymmetry`` integer (0=none, 1=XZ, 2=YZ, 3=XZYZ).  If
        ``None``, defaults to XZ (1) for typical ship/FPSO hulls.
    gdf_tol:
        Clipping tolerance in metres passed to ``SaveSymmetrisedBodyMesh``.

    Returns
    -------
    Path to the PNG if successful, ``None`` otherwise.

    Raises
    ------
    NotImplementedError
        Always — this stub must be completed once a licence-holding environment
        is available to validate the GDF export round-trip.
    """
    raise NotImplementedError(
        "capture_model_schematic is a stub (WRK-310). "
        "Implementation deferred pending OrcFxAPI licence validation. "
        "See the docstring and skill "
        "workspace-hub/.claude/skills/engineering/marine-offshore/"
        "orcaflex-visualization/SKILL.md for the recommended approach."
    )


def img_to_base64(image_path: str | Path) -> str:
    """Convert an image file to a ``data:image/...;base64,`` URI.

    Suitable for embedding directly in HTML ``<img src="...">`` tags.
    Supports BMP, PNG, JPEG.

    Parameters
    ----------
    image_path:
        Path to the image file.

    Returns
    -------
    Data URI string.
    """
    image_path = Path(image_path)
    ext = image_path.suffix.lower().lstrip(".")
    mime = {
        "bmp": "image/bmp",
        "png": "image/png",
        "jpg": "image/jpeg",
        "jpeg": "image/jpeg",
    }.get(ext, "image/png")
    data = image_path.read_bytes()
    b64 = base64.b64encode(data).decode("ascii")
    return f"data:{mime};base64,{b64}"
