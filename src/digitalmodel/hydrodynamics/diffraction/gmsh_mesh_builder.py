#!/usr/bin/env python3
"""
ABOUTME: gmsh mesh builder integration — generates panel meshes from geometry
specs and exports to GDF (OrcaWave/WAMIT), DAT (AQWA), and MSH v2.2
(BEMRosetta/Nemoh) formats. Part of the WRK-140 solver pipeline integration.

Usage::

    from digitalmodel.hydrodynamics.diffraction.gmsh_mesh_builder import (
        GmshMeshBuilder,
        GmshMeshSpec,
    )

    spec = GmshMeshSpec(
        geometry_type="box_barge",
        length=100.0,
        beam=30.0,
        draft=6.0,
        mesh_size=5.0,
    )
    builder = GmshMeshBuilder()
    result = builder.build(spec, output_dir=Path("output"), formats=["gdf"])
    print(result.output_files["gdf"])
"""

from __future__ import annotations

import tempfile
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional

import numpy as np
from pydantic import BaseModel, Field, model_validator

try:
    import gmsh
    GMSH_AVAILABLE = True
except ImportError:
    GMSH_AVAILABLE = False


# ---------------------------------------------------------------------------
# Supported geometry types
# ---------------------------------------------------------------------------

_VALID_GEOMETRY_TYPES = frozenset({"box_barge", "cylinder"})

# Physical gravity constant used in GDF header
_GRAVITY = 9.80665


# ---------------------------------------------------------------------------
# GDF export helpers
# ---------------------------------------------------------------------------


def _build_gdf_header(n_panels: int, symmetry: bool = False) -> str:
    """Build the four-line GDF file header.

    GDF format:
        Line 1: Title comment
        Line 2: ULEN  GRAV
        Line 3: ISX  ISY  (symmetry about xz and yz planes)
        Line 4: NPANEL

    Args:
        n_panels: Total number of panels in the file.
        symmetry: If True, set ISX=1 (symmetry about the xz-plane).

    Returns:
        Four-line header string (trailing newline included).
    """
    title = "gmsh panel mesh — generated by digitalmodel gmsh_mesh_builder"
    ulen_grav = f"  1.0  {_GRAVITY:.5f}"
    isx = 1 if symmetry else 0
    sym_line = f"  {isx}  0"
    npanel_line = f"  {n_panels}"
    return "\n".join([title, ulen_grav, sym_line, npanel_line]) + "\n"


def _panel_to_gdf_line(verts: np.ndarray) -> str:
    """Format a single GDF panel line.

    GDF expects 4 vertices per panel (triangles repeat vertex 2).
    Each vertex is written as "  X  Y  Z".

    Args:
        verts: (3, 3) or (4, 3) array of vertex coordinates.

    Returns:
        Single-line GDF panel record.
    """
    if len(verts) == 3:
        pts = [verts[0], verts[1], verts[2], verts[2]]
    else:
        pts = [verts[0], verts[1], verts[2], verts[3]]

    parts = []
    for p in pts:
        parts.extend([f"{p[0]:.6f}", f"{p[1]:.6f}", f"{p[2]:.6f}"])
    return "  " + "  ".join(parts)


# ---------------------------------------------------------------------------
# DAT export helpers
# ---------------------------------------------------------------------------


def _node_to_dat_line(node_id: int, xyz: tuple) -> str:
    """Format an AQWA NODE record.

    Args:
        node_id: 1-based node identifier.
        xyz: (x, y, z) coordinates.

    Returns:
        AQWA NODE card string.
    """
    x, y, z = xyz
    return f"NODE  {node_id:6d}  {x:12.4f}  {y:12.4f}  {z:12.4f}"


def _panel_to_dat_line(panel_id: int, node_ids: tuple) -> str:
    """Format an AQWA QPPL DIFF panel record.

    AQWA uses QPPL DIFF cards with four node IDs. Triangles repeat
    the third node in the fourth position.

    Args:
        panel_id: 1-based panel identifier (unused in DAT format
            but kept for interface consistency).
        node_ids: Tuple of 3 or 4 node IDs (1-based).

    Returns:
        AQWA QPPL DIFF card string.
    """
    if len(node_ids) == 3:
        n1, n2, n3 = node_ids
        n4 = n3
    else:
        n1, n2, n3, n4 = node_ids
    return f"QPPL DIFF  {n1:6d}  {n2:6d}  {n3:6d}  {n4:6d}"


# ---------------------------------------------------------------------------
# Data models
# ---------------------------------------------------------------------------


class GmshMeshSpec(BaseModel):
    """Geometry specification for gmsh-based panel mesh generation.

    Supported geometry types:
    - ``box_barge``: Rectangular barge — requires length, beam, draft.
    - ``cylinder``: Vertical cylinder — requires radius, draft.
    """

    geometry_type: str = Field(
        ...,
        description="Geometry type: 'box_barge' or 'cylinder'",
    )
    mesh_size: float = Field(
        default=2.0,
        gt=0,
        description="Target element characteristic length (m)",
    )

    # Box barge parameters
    length: Optional[float] = Field(
        None, gt=0, description="Barge length (m), required for box_barge"
    )
    beam: Optional[float] = Field(
        None, gt=0, description="Barge beam / width (m), required for box_barge"
    )
    draft: Optional[float] = Field(
        None, gt=0, description="Draft depth (m), required for box_barge / cylinder"
    )

    # Cylinder parameters
    radius: Optional[float] = Field(
        None, gt=0, description="Cylinder radius (m), required for cylinder"
    )

    @model_validator(mode="after")
    def validate_geometry_type(self) -> "GmshMeshSpec":
        if self.geometry_type not in _VALID_GEOMETRY_TYPES:
            raise ValueError(
                f"Unknown geometry_type '{self.geometry_type}'. "
                f"Supported: {sorted(_VALID_GEOMETRY_TYPES)}"
            )
        return self

    def validate_for_geometry(self) -> None:
        """Raise ValueError if required fields for geometry_type are missing."""
        if self.geometry_type == "box_barge":
            missing = [
                f for f in ("length", "beam", "draft")
                if getattr(self, f) is None
            ]
            if missing:
                raise ValueError(
                    f"box_barge requires: {missing}"
                )
        elif self.geometry_type == "cylinder":
            missing = [
                f for f in ("radius", "draft")
                if getattr(self, f) is None
            ]
            if missing:
                raise ValueError(
                    f"cylinder requires: {missing}"
                )

    @classmethod
    def from_dict(cls, data: dict) -> "GmshMeshSpec":
        """Construct from a raw dictionary.

        Args:
            data: Dictionary with geometry spec fields.

        Returns:
            GmshMeshSpec instance.
        """
        return cls(**data)


@dataclass
class MeshExportResult:
    """Result of a mesh build + export operation.

    Attributes:
        n_panels: Number of surface panels in the generated mesh.
        n_nodes: Number of nodes in the generated mesh.
        geometry_type: Geometry type that was meshed.
        output_files: Mapping of format name (``"gdf"``, ``"dat"``,
            ``"msh"``) to absolute file path string.
    """

    n_panels: int
    n_nodes: int
    geometry_type: str
    output_files: Dict[str, str] = field(default_factory=dict)

    def to_dict(self) -> dict:
        """Serialise to a plain dictionary."""
        return {
            "n_panels": self.n_panels,
            "n_nodes": self.n_nodes,
            "geometry_type": self.geometry_type,
            "output_files": dict(self.output_files),
        }


# ---------------------------------------------------------------------------
# Core builder
# ---------------------------------------------------------------------------


class GmshMeshBuilder:
    """Generate panel meshes using the gmsh Python API.

    Creates wetted surface meshes for hydrodynamic BEM solvers and
    exports them to GDF (OrcaWave/WAMIT), DAT (AQWA), and MSH v2.2
    (BEMRosetta/Nemoh) formats.

    Requires gmsh >= 4.11: ``pip install gmsh``
    """

    SUPPORTED_GEOMETRIES: List[str] = sorted(_VALID_GEOMETRY_TYPES)

    # -----------------------------------------------------------------
    # Public API
    # -----------------------------------------------------------------

    def build(
        self,
        spec: GmshMeshSpec,
        output_dir: Path,
        formats: List[str],
        output_stem: Optional[str] = None,
    ) -> MeshExportResult:
        """Generate a mesh from spec and export to the requested formats.

        Args:
            spec: Geometry specification.
            output_dir: Directory where output files are written.
            formats: List of output format names, any of
                ``"gdf"``, ``"dat"``, ``"msh"``.
            output_stem: Stem for output filenames. Defaults to the
                geometry type (e.g. ``"box_barge"``).

        Returns:
            MeshExportResult with panel/node counts and file paths.

        Raises:
            ImportError: If gmsh is not installed.
            ValueError: If the spec is missing required fields.
        """
        if not GMSH_AVAILABLE:
            raise ImportError(
                "gmsh Python package is required. Install: pip install gmsh"
            )

        spec.validate_for_geometry()

        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

        if output_stem is None:
            output_stem = spec.geometry_type

        # Generate mesh and extract surface triangles/quads
        nodes, panels = self._generate_surface_mesh(spec)

        n_nodes = len(nodes)
        n_panels = len(panels)

        output_files: Dict[str, str] = {}

        for fmt in formats:
            fmt = fmt.lower()
            if fmt == "gdf":
                path = output_dir / f"{output_stem}.gdf"
                self._write_gdf(nodes, panels, path)
                output_files["gdf"] = str(path)
            elif fmt == "dat":
                path = output_dir / f"{output_stem}.dat"
                self._write_dat(nodes, panels, path)
                output_files["dat"] = str(path)
            elif fmt == "msh":
                path = output_dir / f"{output_stem}.msh"
                self._write_msh_v22(spec, path)
                output_files["msh"] = str(path)
            else:
                raise ValueError(
                    f"Unsupported format '{fmt}'. Use: gdf, dat, msh"
                )

        return MeshExportResult(
            n_panels=n_panels,
            n_nodes=n_nodes,
            geometry_type=spec.geometry_type,
            output_files=output_files,
        )

    # -----------------------------------------------------------------
    # Geometry generation
    # -----------------------------------------------------------------

    def _generate_surface_mesh(
        self, spec: GmshMeshSpec
    ) -> tuple:
        """Run gmsh and extract surface mesh data.

        Args:
            spec: Geometry specification.

        Returns:
            (nodes, panels) where:
            - nodes: (N, 3) float64 array of node coordinates
            - panels: list of node-index arrays per panel (0-based)
        """
        gmsh.initialize()
        gmsh.option.setNumber("General.Terminal", 0)

        try:
            gmsh.model.add("surface_mesh")
            gmsh.option.setNumber("Mesh.MshFileVersion", 2.2)

            if spec.geometry_type == "box_barge":
                self._create_box_barge_geometry(spec)
            elif spec.geometry_type == "cylinder":
                self._create_cylinder_geometry(spec)

            gmsh.option.setNumber("Mesh.Algorithm", 6)
            gmsh.option.setNumber("Mesh.MeshSizeMax", spec.mesh_size)
            gmsh.option.setNumber("Mesh.MeshSizeMin", spec.mesh_size * 0.5)
            gmsh.option.setNumber("Mesh.Smoothing", 5)
            gmsh.model.mesh.generate(2)

            nodes, panels = self._extract_surface_data()
        finally:
            gmsh.finalize()

        return nodes, panels

    def _create_box_barge_geometry(self, spec: GmshMeshSpec) -> None:
        """Build wetted box barge surfaces in gmsh.

        Creates a box of dimensions length × beam × draft, then
        marks all faces except the waterplane (z=0 top face) as the
        wetted physical group. Origin at mid-ship waterline.

        Args:
            spec: GmshMeshSpec with length, beam, draft fields.
        """
        hL = spec.length / 2.0
        hB = spec.beam / 2.0
        d = spec.draft

        box_tag = gmsh.model.occ.addBox(-hL, -hB, -d, spec.length, spec.beam, d)
        gmsh.model.occ.synchronize()

        surfaces = gmsh.model.getEntities(dim=2)
        wetted = []
        for dim, tag in surfaces:
            com = gmsh.model.occ.getCenterOfMass(dim, tag)
            if com[2] < -1e-6:
                wetted.append(tag)

        gmsh.model.addPhysicalGroup(2, wetted, name="wetted_surface")

    def _create_cylinder_geometry(self, spec: GmshMeshSpec) -> None:
        """Build wetted cylinder surfaces in gmsh.

        Creates a vertical cylinder of radius/draft, marks the lateral
        surface and bottom cap as wetted (excludes waterplane top).

        Args:
            spec: GmshMeshSpec with radius and draft fields.
        """
        d = spec.draft
        r = spec.radius

        cyl_tag = gmsh.model.occ.addCylinder(0, 0, -d, 0, 0, d, r)
        gmsh.model.occ.synchronize()

        surfaces = gmsh.model.getEntities(dim=2)
        wetted = []
        for dim, tag in surfaces:
            com = gmsh.model.occ.getCenterOfMass(dim, tag)
            if com[2] < -1e-6:
                wetted.append(tag)

        gmsh.model.addPhysicalGroup(2, wetted, name="wetted_surface")

    def _extract_surface_data(self) -> tuple:
        """Extract 2D surface mesh nodes and panels from gmsh.

        Returns:
            (nodes, panels) tuple where nodes is (N, 3) float64 and
            panels is a list of 3- or 4-element int arrays (0-based).
        """
        node_tags, coords, _ = gmsh.model.mesh.getNodes()
        nodes = coords.reshape(-1, 3).astype(np.float64)
        tag_to_idx = {int(t): i for i, t in enumerate(node_tags)}

        panels = []
        elem_types, elem_tags_list, node_tags_list = (
            gmsh.model.mesh.getElements(dim=2)
        )

        for etype, etags, enodes in zip(
            elem_types, elem_tags_list, node_tags_list
        ):
            prop = gmsh.model.mesh.getElementProperties(etype)
            n_per = prop[3]
            for j in range(len(etags)):
                raw = enodes[j * n_per : (j + 1) * n_per]
                panel = [tag_to_idx[int(t)] for t in raw]
                panels.append(panel)

        return nodes, panels

    # -----------------------------------------------------------------
    # Format writers
    # -----------------------------------------------------------------

    def _write_gdf(
        self, nodes: np.ndarray, panels: list, output_path: Path
    ) -> None:
        """Write mesh to WAMIT/OrcaWave GDF format.

        Args:
            nodes: (N, 3) array of node coordinates.
            panels: List of panel index arrays (0-based).
            output_path: Destination file path.
        """
        lines = [_build_gdf_header(n_panels=len(panels), symmetry=False)]
        for panel in panels:
            verts = nodes[panel]
            lines.append(_panel_to_gdf_line(verts))
        output_path.write_text("\n".join(lines) + "\n")

    def _write_dat(
        self, nodes: np.ndarray, panels: list, output_path: Path
    ) -> None:
        """Write mesh to AQWA .DAT format.

        Nodes are written as 1-based NODE records followed by
        QPPL DIFF panel records. Triangular panels repeat the third
        node in the fourth position as required by AQWA.

        Args:
            nodes: (N, 3) array of node coordinates.
            panels: List of panel index arrays (0-based).
            output_path: Destination file path.
        """
        lines: List[str] = []
        for i, xyz in enumerate(nodes):
            lines.append(_node_to_dat_line(i + 1, tuple(xyz)))
        for i, panel in enumerate(panels):
            # Convert 0-based indices to 1-based AQWA node IDs
            node_ids = tuple(idx + 1 for idx in panel)
            lines.append(_panel_to_dat_line(i + 1, node_ids))
        output_path.write_text("\n".join(lines) + "\n")

    def _write_msh_v22(self, spec: GmshMeshSpec, output_path: Path) -> None:
        """Re-run gmsh to write a native MSH v2.2 file.

        MSH v2.2 (ASCII) is required by BEMRosetta, Nemoh, and other
        BEM tools. gmsh.write() directly generates the correct format.

        Args:
            spec: Geometry spec (re-run gmsh for native write).
            output_path: Destination .msh file path.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            tmp_msh = Path(tmpdir) / "mesh.msh"

            gmsh.initialize()
            gmsh.option.setNumber("General.Terminal", 0)
            try:
                gmsh.model.add("msh_export")
                gmsh.option.setNumber("Mesh.MshFileVersion", 2.2)
                gmsh.option.setNumber("Mesh.Binary", 0)

                if spec.geometry_type == "box_barge":
                    self._create_box_barge_geometry(spec)
                elif spec.geometry_type == "cylinder":
                    self._create_cylinder_geometry(spec)

                gmsh.option.setNumber("Mesh.Algorithm", 6)
                gmsh.option.setNumber("Mesh.MeshSizeMax", spec.mesh_size)
                gmsh.option.setNumber("Mesh.MeshSizeMin", spec.mesh_size * 0.5)
                gmsh.model.mesh.generate(2)

                gmsh.write(str(tmp_msh))
            finally:
                gmsh.finalize()

            import shutil
            shutil.copy(str(tmp_msh), str(output_path))


__all__ = [
    "GMSH_AVAILABLE",
    "GmshMeshSpec",
    "GmshMeshBuilder",
    "MeshExportResult",
    "_build_gdf_header",
    "_panel_to_gdf_line",
    "_node_to_dat_line",
    "_panel_to_dat_line",
]
